#pragma once

#include <array>
#include <atomic>
#include <optional>
#include <cassert>
#include <type_traits>

namespace ngl {
namespace thread {

    void TestCode();

    /**
     * @brief ロックフリーで実装された固定サイズのスタックデータ構造
     * 
     * このコードはGitHub Copilot Agentによって生成され、レビュー・検証されたものです。
     * 
     * スレッドセーフティレベル：
     * - 完全なスレッドセーフ
     * - 複数スレッドから同時にPush/Pop操作が可能
     * - std::atomicとcompare_exchange_weak操作によるロックフリー実装
     * - ABAプロブレムに対する基本的な保護機能あり（フリーリストによる管理）
     * 
     * 制限事項：
     * - 最大要素数は固定（MaxSize）
     * - メモリ順序は暗黙的なstd::memory_order_seqCst
     * 
     * @note Generated by GitHub Copilot Agent (2025-04-19)
     * @tparam T スタックに格納する要素の型
     * @tparam MaxSize スタックの最大要素数
     */
    template<typename T, size_t MaxSize>
    class FixedSizeLockFreeStack {
    private:
        struct Node {
            T data;
            size_t next;  // インデックスとして使用
        };
    
        static constexpr size_t INVALID_INDEX = static_cast<size_t>(-1);
        
        // 実際のデータを格納する配列
        std::array<Node, MaxSize> nodes_;
        // フリーリストの先頭インデックス
        std::atomic<size_t> freeList_;
        // スタックの先頭インデックス
        std::atomic<size_t> head_;
    
    public:
        FixedSizeLockFreeStack() : head_(INVALID_INDEX) {
            // フリーリストの初期化
            for (size_t i = 0; i < MaxSize - 1; ++i) {
                nodes_[i].next = i + 1;
            }
            nodes_[MaxSize - 1].next = INVALID_INDEX;
            freeList_.store(0);
        }
    
        bool Push(const T& value) {
            // フリーリストから新しいノードを取得
            size_t newIndex = freeList_.load();
            if (newIndex == INVALID_INDEX) {
                return false;  // スタックが満杯
            }
    
            while (true) {
                size_t nextFree = nodes_[newIndex].next;
                if (freeList_.compare_exchange_weak(newIndex, nextFree)) {
                    break;
                }
                if (newIndex == INVALID_INDEX) {
                    return false;  // 他のスレッドがノードを使用
                }
            }
    
            // 新しいノードを設定
            nodes_[newIndex].data = value;
            
            while (true) {
                size_t oldHead = head_.load();
                nodes_[newIndex].next = oldHead;
                
                if (head_.compare_exchange_weak(oldHead, newIndex)) {
                    return true;
                }
            }
        }
    
        std::optional<T> Pop() {
            while (true) {
                size_t oldHead = head_.load();
                if (oldHead == INVALID_INDEX) {
                    return std::nullopt;  // スタックが空
                }
    
                size_t newHead = nodes_[oldHead].next;
                if (head_.compare_exchange_weak(oldHead, newHead)) {
                    T result = nodes_[oldHead].data;
                    
                    // ノードをフリーリストに戻す
                    while (true) {
                        size_t oldFree = freeList_.load();
                        nodes_[oldHead].next = oldFree;
                        if (freeList_.compare_exchange_weak(oldFree, oldHead)) {
                            break;
                        }
                    }
    
                    return result;
                }
            }
        }
    
        bool IsEmpty() const {
            return head_.load() == INVALID_INDEX;
        }
    
        bool IsFull() const {
            return freeList_.load() == INVALID_INDEX;
        }
    
        size_t Capacity() const {
            return MaxSize;
        }
    };

} // namespace thread
} // namespace ngl