#pragma once

#include <vector>
#include <atomic>
#include <optional>
#include <memory>
#include <cassert>
#include <type_traits>

namespace ngl {
namespace thread {

    /**
     * @brief 実行時に固定サイズを指定するロックフリースタック実装
     * 
     * このコードはGitHub Copilot Agentによって生成され、レビュー・検証されたものです。
     * 
     * スレッドセーフティレベル：
     * - 完全なスレッドセーフ
     * - 複数スレッドから同時にPush/Pop操作が可能
     * - std::atomicとcompare_exchange_weak操作によるロックフリー実装
     * - ABAプロブレムに対する基本的な保護機能あり（フリーリストによる管理）
     * 
     * 特徴：
     * - 実行時にサイズを指定（コンストラクタ引数）
     * - ヒープメモリを使用（std::vector）
     * - 大規模データに適している
     * - 初期化後はサイズ固定
     * 
     * 制限事項：
     * - メモリ順序は暗黙的なstd::memory_order_seqCst
     * - 一度確保したサイズは変更不可
     * 
     * @note Generated by GitHub Copilot Agent (2025-04-19)
     * @tparam T スタックに格納する要素の型
     */
    template<typename T>
    class FixedSizeLockFreeStack {
    private:
        struct Node {
            T data;
            size_t next;  // インデックスとして使用
        };
    
        static constexpr size_t INVALID_INDEX = static_cast<size_t>(-1);
        
        // 実際のデータを格納するベクター
        std::vector<Node> nodes_;
        // フリーリストの先頭インデックス
        std::atomic<size_t> freeList_;
        // スタックの先頭インデックス
        std::atomic<size_t> head_;
        // キャパシティ（要素数）
        size_t capacity_;
        // 初期化済みフラグ
        bool initialized_;
    
    public:
        FixedSizeLockFreeStack()
            : nodes_()
            , freeList_(INVALID_INDEX)
            , head_(INVALID_INDEX)
            , capacity_(0)
            , initialized_(false)
        {
        }

        // Initialize関数で明示的に初期化
        bool Initialize(size_t capacity) {
            if (initialized_) {
                return false;  // 既に初期化済み
            }

            capacity_ = capacity;
            nodes_.resize(capacity);

            // フリーリストの初期化
            for (size_t i = 0; i < capacity_ - 1; ++i) {
                nodes_[i].next = i + 1;
            }
            nodes_[capacity_ - 1].next = INVALID_INDEX;
            freeList_.store(0);
            head_.store(INVALID_INDEX);
            
            initialized_ = true;
            return true;
        }

        // ムーブコンストラクタを削除（スレッドセーフティのため）
        FixedSizeLockFreeStack(FixedSizeLockFreeStack&&) = delete;
        // コピーコンストラクタを削除
        FixedSizeLockFreeStack(const FixedSizeLockFreeStack&) = delete;
        // ムーブ代入演算子を削除
        FixedSizeLockFreeStack& operator=(FixedSizeLockFreeStack&&) = delete;
        // コピー代入演算子を削除
        FixedSizeLockFreeStack& operator=(const FixedSizeLockFreeStack&) = delete;

        bool Push(const T& value) {
            assert(initialized_ && "Stack must be initialized before use");

            // フリーリストから新しいノードを取得
            size_t newIndex = freeList_.load();
            if (newIndex == INVALID_INDEX) {
                return false;  // スタックが満杯
            }
    
            while (true) {
                size_t nextFree = nodes_[newIndex].next;
                if (freeList_.compare_exchange_weak(newIndex, nextFree)) {
                    break;
                }
                if (newIndex == INVALID_INDEX) {
                    return false;  // 他のスレッドがノードを使用
                }
            }
    
            // 新しいノードを設定
            nodes_[newIndex].data = value;
            
            while (true) {
                size_t oldHead = head_.load();
                nodes_[newIndex].next = oldHead;
                
                if (head_.compare_exchange_weak(oldHead, newIndex)) {
                    return true;
                }
            }
        }
    
        std::optional<T> Pop() {
            assert(initialized_ && "Stack must be initialized before use");

            while (true) {
                size_t oldHead = head_.load();
                if (oldHead == INVALID_INDEX) {
                    return std::nullopt;  // スタックが空
                }
    
                size_t newHead = nodes_[oldHead].next;
                if (head_.compare_exchange_weak(oldHead, newHead)) {
                    T result = nodes_[oldHead].data;
                    
                    // ノードをフリーリストに戻す
                    while (true) {
                        size_t oldFree = freeList_.load();
                        nodes_[oldHead].next = oldFree;
                        if (freeList_.compare_exchange_weak(oldFree, oldHead)) {
                            break;
                        }
                    }
    
                    return result;
                }
            }
        }
    
        bool IsEmpty() const {
            assert(initialized_ && "Stack must be initialized before use");
            return head_.load() == INVALID_INDEX;
        }
    
        bool IsFull() const {
            assert(initialized_ && "Stack must be initialized before use");
            return freeList_.load() == INVALID_INDEX;
        }
    
        bool IsInitialized() const {
            return initialized_;
        }

        size_t Capacity() const {
            assert(initialized_ && "Stack must be initialized before use");
            return capacity_;
        }
    };

} // namespace thread
} // namespace ngl